<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Чат с Gemini (Material 3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* --- Material 3 Цветовая Схема и Пользовательские Стили --- */
        :root {
            /* Light Theme Colors */
            --md-sys-color-primary: #006399;
            --md-sys-color-on-primary: #ffffff;
            --md-sys-color-primary-container: #cbe6ff;
            --md-sys-color-on-primary-container: #001e31;
            --md-sys-color-secondary: #50606e;
            --md-sys-color-on-secondary: #ffffff;
            --md-sys-color-secondary-container: #d3e5f5;
            --md-sys-color-on-secondary-container: #0c1d29;
            --md-sys-color-tertiary-container: #dcebf9;
            --md-sys-color-on-tertiary-container: #0e1c27;
            --md-sys-color-surface: #f8f9ff;
            --md-sys-color-on-surface: #191c1e;
            --md-sys-color-surface-variant: #dee3eb;
            --md-sys-color-on-surface-variant: #42474e;
            --md-sys-color-background: #f8f9ff;
            --md-sys-color-on-background: #191c1e;
            --md-sys-color-outline: #72787e;
            --md-sys-color-shadow: #000000;
        }

        html.dark {
            /* Dark Theme Colors */
            --md-sys-color-primary: #92ccff;
            --md-sys-color-on-primary: #003351;
            --md-sys-color-primary-container: #004a72;
            --md-sys-color-on-primary-container: #cbe6ff;
            --md-sys-color-secondary: #b7c9d9;
            --md-sys-color-on-secondary: #22323f;
            --md-sys-color-secondary-container: #384956;
            --md-sys-color-on-secondary-container: #d3e5f5;
            --md-sys-color-tertiary-container: #263340;
            --md-sys-color-on-tertiary-container: #d3e5f5;
            --md-sys-color-surface: #111416;
            --md-sys-color-on-surface: #e1e2e5;
            --md-sys-color-surface-variant: #42474e;
            --md-sys-color-on-surface-variant: #c2c7ce;
            --md-sys-color-background: #191c1e;
            --md-sys-color-on-background: #e1e2e5;
            --md-sys-color-outline: #8c9198;
            --md-sys-color-shadow: #000000;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
        }
        
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animate-fade-in {
            animation: fade-in 0.3s ease-out forwards;
        }

        .animate-bounce-dot {
            animation: bounce-dot 1.4s infinite ease-in-out both;
        }

        @keyframes bounce-dot {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        textarea {
            overflow-y: hidden;
        }
        
        /* Пользовательские стили для полосы прокрутки */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--md-sys-color-surface-variant); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: var(--md-sys-color-outline); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--md-sys-color-on-surface-variant); }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            padding: 2rem;
            border-radius: 1.5rem; /* rounded-3xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            max-width: 90%;
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            text-align: center;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden">

    <!-- API Key Modal -->
    <div id="api-key-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-[var(--md-sys-color-on-surface)]">Добро пожаловать в AI Чат с Gemini!</h2>
            <p class="text-[var(--md-sys-color-on-surface-variant)]">Для использования этого чата, пожалуйста, введите ваш Gemini API ключ. Его можно получить на <a href="https://makersuite.google.com/app/apikey" target="_blank" class="text-[var(--md-sys-color-primary)] hover:underline">Google AI Studio</a>.</p>
            <input type="password" id="api-key-input" class="p-3 rounded-xl bg-[var(--md-sys-color-surface-variant)] text-[var(--md-sys-color-on-surface-variant)] focus:outline-none focus:ring-2 focus:ring-[var(--md-sys-color-primary)]" placeholder="Ваш Gemini API ключ">
            <button id="api-key-save-button" class="w-full flex items-center justify-center gap-2 px-4 py-3 bg-[var(--md-sys-color-primary)] text-[var(--md-sys-color-on-primary)] rounded-xl font-semibold hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
                Сохранить ключ
            </button>
        </div>
    </div>

    <div id="chat-app-container" class="flex h-full hidden"> <!-- Initially hidden -->
        <!-- Sidebar (История чатов) -->
        <aside id="sidebar" class="bg-[var(--md-sys-color-surface)] w-64 flex-col p-4 border-r border-[var(--md-sys-color-outline)] absolute md:relative z-20 md:z-auto h-full -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out">
            <button id="new-chat-button" class="w-full flex items-center justify-center gap-2 px-4 py-3 bg-[var(--md-sys-color-primary-container)] text-[var(--md-sys-color-on-primary-container)] rounded-2xl font-semibold hover:opacity-90 transition-opacity">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="currentColor"><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6Z"/></svg>
                Новый чат
            </button>
            <h2 class="text-sm font-bold text-[var(--md-sys-color-on-surface-variant)] mt-6 mb-2 px-2">История</h2>
            <nav id="chat-history-list" class="flex-1 overflow-y-auto space-y-1"></nav>
        </aside>

        <!-- Основной контент чата -->
        <main class="flex-1 flex flex-col h-full bg-[var(--md-sys-color-background)]">
            <header class="bg-[var(--md-sys-color-surface)] text-[var(--md-sys-color-on-surface)] p-4 shadow-sm flex justify-between items-center border-b border-[var(--md-sys-color-outline)]">
                <div class="flex items-center gap-2">
                    <button id="menu-button" class="md:hidden p-2 rounded-full hover:bg-[var(--md-sys-color-surface-variant)]">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                    </button>
                    <h1 class="text-xl font-bold">AI Чат с Gemini</h1>
                </div>
                <button id="theme-switcher" class="p-2 rounded-full hover:bg-[var(--md-sys-color-surface-variant)] transition-colors">
                    <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                    <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                </button>
            </header>

            <div id="messages-container" class="flex-1 overflow-y-auto p-4 md:p-6 space-y-6"></div>
            
            <div id="ai-features-container" class="px-4 md:px-6 pt-2"></div>

            <div class="p-4 bg-[var(--md-sys-color-surface)]">
                <div class="flex items-start space-x-3">
                    <textarea id="user-input" class="flex-1 p-3 md:p-4 bg-[var(--md-sys-color-surface-variant)] text-[var(--md-sys-color-on-surface-variant)] rounded-2xl focus:outline-none focus:ring-2 focus:ring-[var(--md-sys-color-primary)] resize-none h-12 overflow-hidden transition-all duration-200 ease-in-out" placeholder="Напишите ваше сообщение..." rows="1" style="min-height: 48px; max-height: 120px;"></textarea>
                    <button id="send-button" class="bg-[var(--md-sys-color-primary)] text-[var(--md-sys-color-on-primary)] p-3 rounded-full shadow-lg hover:opacity-90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--md-sys-color-primary)] transition-opacity disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transform rotate-90" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>
                    </button>
                </div>
                <div class="flex flex-wrap justify-center gap-2 mt-3">
                    <button id="summarize-button" class="flex items-center gap-2 px-4 py-2 text-sm font-medium bg-[var(--md-sys-color-secondary-container)] text-[var(--md-sys-color-on-secondary-container)] rounded-full hover:opacity-90 transition-opacity disabled:opacity-50">
                        ✨ Суммировать чат
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script>
        // DOM Элементы
        const messagesContainer = document.getElementById('messages-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const themeSwitcher = document.getElementById('theme-switcher');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        const newChatButton = document.getElementById('new-chat-button');
        const chatHistoryList = document.getElementById('chat-history-list');
        const sidebar = document.getElementById('sidebar');
        const menuButton = document.getElementById('menu-button');
        const summarizeButton = document.getElementById('summarize-button');
        const aiFeaturesContainer = document.getElementById('ai-features-container');

        // New DOM elements for API key modal
        const apiKeyModal = document.getElementById('api-key-modal');
        const apiKeyInput = document.getElementById('api-key-input');
        const apiKeySaveButton = document.getElementById('api-key-save-button');
        const chatAppContainer = document.getElementById('chat-app-container');

        // Глобальное состояние
        let allChats = []; // Хранит все чаты: [{ id, title, messages: [{ role, text }] }]
        let currentChatId = null;
        let isLoading = false;
        let geminiApiKey = null; // Stores the Gemini API key

        // --- Инициализация ---
        const init = () => {
            // Check for saved theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
                moonIcon.classList.remove('hidden');
                sunIcon.classList.add('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }

            // Check for API Key
            const savedApiKey = localStorage.getItem('geminiApiKey');
            if (savedApiKey) {
                geminiApiKey = savedApiKey;
                showChatApp();
                loadInitialChatData();
            } else {
                showApiKeyModal();
            }
            attachEventListeners();
        };

        const showApiKeyModal = () => {
            apiKeyModal.classList.remove('hidden');
            chatAppContainer.classList.add('hidden');
            apiKeyInput.focus();
        };

        const hideApiKeyModal = () => {
            apiKeyModal.classList.add('hidden');
            chatAppContainer.classList.remove('hidden');
        };

        const showChatApp = () => {
            chatAppContainer.classList.remove('hidden');
        };

        const loadInitialChatData = () => {
            const savedChats = localStorage.getItem('geminiChats');
            if (savedChats) {
                allChats = JSON.parse(savedChats);
            }
            
            renderChatHistory();

            if (allChats.length > 0) {
                // Load the last active chat, or the most recent one by ID
                const lastChat = allChats.reduce((prev, current) => (prev.id > current.id) ? prev : current);
                loadChat(lastChat.id);
            } else {
                createNewChat();
            }
        };
        
        // --- Управление Историей Чатов и Хранилищем ---
        const saveChatsToLocalStorage = () => {
            localStorage.setItem('geminiChats', JSON.stringify(allChats));
        };

        const renderChatHistory = () => {
            chatHistoryList.innerHTML = '';
            // Sort chats by ID in descending order to show most recent at the top
            [...allChats].sort((a, b) => b.id - a.id).forEach(chat => {
                const chatLink = document.createElement('a');
                chatLink.href = '#';
                chatLink.textContent = chat.title;
                chatLink.dataset.chatId = chat.id;
                chatLink.className = `block w-full text-left px-3 py-2 rounded-lg truncate text-sm font-medium transition-colors ${
                    chat.id === currentChatId 
                        ? 'bg-[var(--md-sys-color-secondary-container)] text-[var(--md-sys-color-on-secondary-container)]' 
                        : 'text-[var(--md-sys-color-on-surface-variant)] hover:bg-[var(--md-sys-color-surface-variant)]'
                }`;
                chatLink.onclick = (e) => {
                    e.preventDefault();
                    loadChat(chat.id);
                    if (window.innerWidth < 768) {
                        sidebar.classList.add('-translate-x-full');
                    }
                };
                chatHistoryList.appendChild(chatLink);
            });
        };

        const createNewChat = () => {
            messagesContainer.innerHTML = '';
            aiFeaturesContainer.innerHTML = '';
            currentChatId = null; // Reset current chat to null for a new one
            userInput.value = '';
            userInput.focus();
            renderChatHistory(); // Re-render history to reflect no active chat visually
        };

        const loadChat = (chatId) => {
            const chat = allChats.find(c => c.id === chatId);
            if (!chat) return;
            
            currentChatId = chatId;
            messagesContainer.innerHTML = '';
            aiFeaturesContainer.innerHTML = '';
            chat.messages.forEach(msg => appendMessage(msg.role, msg.text, false)); // Don't animate old messages
            renderChatHistory(); // Highlight the loaded chat in history
            scrollToBottom();
        };

        // --- Управление UI и Сообщениями ---
        const scrollToBottom = () => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };
        
        const appendMessage = (role, text, isAnimated = true) => {
            const messageDiv = document.createElement('div');
            let contentWrapper;

            if (role === 'system') {
                messageDiv.className = 'flex justify-center';
                contentWrapper = document.createElement('div');
                contentWrapper.className = `p-3 my-2 shadow-md max-w-[85%] text-sm bg-[var(--md-sys-color-tertiary-container)] text-[var(--md-sys-color-on-tertiary-container)] rounded-2xl`;
            } else {
                messageDiv.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'}`;
                contentWrapper = document.createElement('div');
                contentWrapper.className = `p-3 md:p-4 shadow-md max-w-[85%] md:max-w-[70%] text-base ${
                    role === 'user'
                        ? 'bg-[var(--md-sys-color-primary)] text-[var(--md-sys-color-on-primary)] rounded-t-2xl rounded-l-2xl'
                        : 'bg-[var(--md-sys-color-surface-variant)] text-[var(--md-sys-color-on-surface-variant)] rounded-t-2xl rounded-r-2xl'
                }`;
            }

            if (isAnimated) {
                contentWrapper.classList.add('animate-fade-in');
            }

            // Regex to find code blocks (```language\ncode\n```)
            const codeRegex = /```(\w+)?\n([\s\S]*?)\n```/g;
            let match;
            let lastIndex = 0;

            const processText = (txt) => {
                // Handle bold text and other basic markdown that doesn't need full parser
                const p = document.createElement('p');
                p.innerHTML = txt
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold text
                    .replace(/\n/g, '<br>'); // Newlines to <br>
                contentWrapper.appendChild(p);
            };

            while ((match = codeRegex.exec(text)) !== null) {
                // Add text before the code block
                if (match.index > lastIndex) {
                    processText(text.substring(lastIndex, match.index));
                }

                // Extract language and code content
                const language = match[1] || 'plaintext';
                const codeContent = match[2].trim();

                // Create code block UI
                const codeBlockContainer = document.createElement('div');
                codeBlockContainer.className = 'bg-gray-800 text-white rounded-lg p-3 my-2 overflow-x-auto border border-gray-700 text-sm';
                
                const codeHeader = document.createElement('div');
                codeHeader.className = 'flex justify-between items-center text-xs text-gray-400 mb-2';
                codeHeader.textContent = language; // Display language

                const actionsDiv = document.createElement('div');
                const copyButton = document.createElement('button');
                copyButton.className = 'bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded text-xs';
                copyButton.textContent = 'Копировать';
                copyButton.onclick = () => {
                    // Using execCommand for better compatibility in iframe environments
                    const el = document.createElement('textarea');
                    el.value = codeContent;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);

                    copyButton.textContent = 'Скопировано!';
                    setTimeout(() => copyButton.textContent = 'Копировать', 2000);
                };
                actionsDiv.appendChild(copyButton);
                codeHeader.appendChild(actionsDiv);

                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.className = 'font-mono';
                code.textContent = codeContent;

                pre.appendChild(code);
                codeBlockContainer.appendChild(codeHeader);
                codeBlockContainer.appendChild(pre);
                contentWrapper.appendChild(codeBlockContainer);

                lastIndex = codeRegex.lastIndex;
            }

            // Add any remaining text after the last code block
            if (lastIndex < text.length) {
                processText(text.substring(lastIndex));
            }

            messageDiv.appendChild(contentWrapper);
            messagesContainer.appendChild(messageDiv);
            if(isAnimated) scrollToBottom();
        };

        const setLoadingState = (state) => {
            isLoading = state;
            const existingLoader = document.getElementById('loading-indicator');
            if (state) {
                if (!existingLoader) {
                    const loaderDiv = document.createElement('div');
                    loaderDiv.id = 'loading-indicator';
                    loaderDiv.className = 'flex justify-start animate-fade-in';
                    loaderDiv.innerHTML = `
                        <div class="p-4 rounded-t-2xl rounded-r-2xl shadow-md bg-[var(--md-sys-color-surface-variant)]">
                            <div class="flex items-center space-x-2">
                                <div class="w-2.5 h-2.5 bg-[var(--md-sys-color-on-surface-variant)] rounded-full animate-bounce-dot" style="animation-delay: 0s;"></div>
                                <div class="w-2.5 h-2.5 bg-[var(--md-sys-color-on-surface-variant)] rounded-full animate-bounce-dot" style="animation-delay: 0.1s;"></div>
                                <div class="w-2.5 h-2.5 bg-[var(--md-sys-color-on-surface-variant)] rounded-full animate-bounce-dot" style="animation-delay: 0.2s;"></div>
                            </div>
                        </div>`;
                    messagesContainer.appendChild(loaderDiv);
                    scrollToBottom();
                }
            } else {
                if (existingLoader) existingLoader.remove();
            }
            sendButton.disabled = state;
            userInput.disabled = state;
            summarizeButton.disabled = state;
        };
        
        // --- Gemini API Функции ---
        
        async function callGeminiAPI(prompt, history = []) {
            if (!geminiApiKey) {
                console.error("Gemini API key is not set.");
                return "Ошибка: Gemini API ключ не установлен. Пожалуйста, введите его.";
            }

            const payload = {
                contents: [...history, { role: "user", parts: [{ text: prompt }] }],
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error.message || 'Неизвестная ошибка API.');
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    return "Не удалось получить ответ от AI. Возможно, ответ был отфильтрован или возникла внутренняя ошибка.";
                }
            } catch (error) {
                console.error('Ошибка вызова Gemini API:', error);
                return `Ошибка: ${error.message}. Пожалуйста, проверьте ваш API-ключ и попробуйте снова.`;
            }
        }
        
        const sendMessage = async (messageText) => {
            const input = messageText || userInput.value.trim();
            if (input === '' || isLoading) return;

            if (currentChatId === null) {
                // If starting a new chat, generate a new ID and title
                const newId = Date.now();
                const newTitle = input.length > 30 ? input.substring(0, 30) + '...' : input;
                const newChat = { id: newId, title: newTitle, messages: [] };
                allChats.push(newChat);
                currentChatId = newId;
                renderChatHistory(); // Update history to show the new chat
            }
            aiFeaturesContainer.innerHTML = ''; // Clear suggested replies

            const currentChat = allChats.find(c => c.id === currentChatId);
            const userMessage = { role: 'user', text: input };
            currentChat.messages.push(userMessage);
            appendMessage('user', input);

            if (!messageText) { // Clear input only if not sent via quick button
                userInput.value = '';
                userInput.style.height = '48px'; // Reset textarea height
            }
            saveChatsToLocalStorage();
            setLoadingState(true);

            // Prepare history for API call: roles are 'user' and 'model'
            const apiHistory = currentChat.messages.slice(0, -1).map(msg => ({
                role: msg.role === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }]
            }));
            
            const aiResponseText = await callGeminiAPI(input, apiHistory);
            const aiMessage = { role: 'ai', text: aiResponseText };
            currentChat.messages.push(aiMessage);
            saveChatsToLocalStorage();
            setLoadingState(false);
            appendMessage('ai', aiResponseText);
            
            // After AI response, suggest replies
            await suggestReplies();
        };

        const summarizeCurrentChat = async () => {
            if (isLoading || currentChatId === null) return;
            const currentChat = allChats.find(c => c.id === currentChatId);
            if (currentChat.messages.length < 2) {
                appendMessage('system', 'Недостаточно сообщений для суммирования чата.');
                return;
            }

            setLoadingState(true);
            const chatContent = currentChat.messages
                .map(m => `${m.role}: ${m.text}`)
                .join('\n');
            const prompt = `Кратко суммируй следующий диалог в нескольких предложениях:\n\n${chatContent}`;
            
            const summary = await callGeminiAPI(prompt);
            setLoadingState(false);
            appendMessage('system', `**Краткое содержание:**\n${summary}`);
        };
        
        const suggestReplies = async () => {
            if (isLoading || currentChatId === null) return;
            const currentChat = allChats.find(c => c.id === currentChatId);
            if (currentChat.messages.length === 0) return; // No messages to base suggestions on
            const lastMessage = currentChat.messages[currentChat.messages.length - 1];

            if (lastMessage.role !== 'ai') return; // Only suggest replies after an AI message

            const prompt = `Основываясь на последнем ответе: "${lastMessage.text}", предложи три коротких, различных варианта ответа для пользователя. Не используй нумерацию или маркеры, просто выведи каждый вариант с новой строки.`;
            
            const suggestionsText = await callGeminiAPI(prompt);
            // Filter out empty lines that might result from splitting
            const suggestions = suggestionsText.split('\n').filter(s => s.trim() !== '');

            aiFeaturesContainer.innerHTML = ''; // Clear previous suggestions
            const container = document.createElement('div');
            container.className = 'flex flex-wrap justify-center gap-2 animate-fade-in';
            suggestions.forEach(suggestion => {
                if (suggestion.trim() === '') return; // Skip empty suggestions
                const button = document.createElement('button');
                button.textContent = `✨ "${suggestion.replace(/"/g, '')}"`; // Remove quotes from suggestion text
                button.className = 'px-3 py-1.5 text-sm font-medium bg-[var(--md-sys-color-secondary-container)] text-[var(--md-sys-color-on-secondary-container)] rounded-full hover:opacity-90 transition-opacity';
                button.onclick = () => {
                    sendMessage(suggestion); // Send the suggested message
                    aiFeaturesContainer.innerHTML = ''; // Clear suggestions after sending
                };
                container.appendChild(button);
            });
            if (suggestions.length > 0) {
                aiFeaturesContainer.appendChild(container);
            }
        };

        // --- Обработчики событий ---
        const attachEventListeners = () => {
            sendButton.addEventListener('click', () => sendMessage());
            summarizeButton.addEventListener('click', summarizeCurrentChat);
            newChatButton.addEventListener('click', createNewChat);
            
            apiKeySaveButton.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();
                if (key) {
                    localStorage.setItem('geminiApiKey', key);
                    geminiApiKey = key;
                    hideApiKeyModal();
                    loadInitialChatData(); // Load chat data after API key is set
                } else {
                    // Simple inline feedback or a temporary message can be added here
                    apiKeyInput.placeholder = "Пожалуйста, введите ключ!";
                    apiKeyInput.classList.add('border-red-500', 'border-2');
                    setTimeout(() => {
                        apiKeyInput.classList.remove('border-red-500', 'border-2');
                        apiKeyInput.placeholder = "Ваш Gemini API ключ";
                    }, 2000);
                }
            });

            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    apiKeySaveButton.click(); // Trigger save button click
                }
            });

            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            userInput.addEventListener('input', () => {
                userInput.style.height = 'auto'; // Reset height
                userInput.style.height = (userInput.scrollHeight) + 'px'; // Set to scroll height
            });

            themeSwitcher.addEventListener('click', () => {
                const isDark = document.documentElement.classList.toggle('dark');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                sunIcon.classList.toggle('hidden', isDark);
                moonIcon.classList.toggle('hidden', !isDark);
            });
            
            menuButton.addEventListener('click', () => {
                sidebar.classList.toggle('-translate-x-full');
            });
        };

        // Запуск приложения
        init();
    </script>
</body>
</html>